<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vegas Craps Table - Online Multiplayer</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #0f3460 100%);
            overflow-x: hidden;
        }
        .casino-chip {
            width: 50px; height: 50px; border-radius: 50%; position: relative;
            display: flex; align-items: center; justify-content: center;
            font-weight: bold; font-size: 13px; cursor: pointer;
            transition: transform 0.2s; box-shadow: 0 4px 8px rgba(0,0,0,0.4);
        }
        .casino-chip.small { width: 35px; height: 35px; font-size: 11px; }
        .casino-chip:hover { transform: scale(1.1); }
        .casino-chip:active { transform: scale(0.95); }
        .casino-chip.dragging { opacity: 0.5; cursor: grabbing !important; }
        .casino-chip::before {
            content: ''; position: absolute; inset: 0; border-radius: 50%; padding: 3px;
            background: repeating-conic-gradient(from 0deg, var(--chip-color) 0deg 18deg, white 18deg 36deg);
            -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
            -webkit-mask-composite: xor; mask-composite: exclude;
        }
        .casino-chip::after {
            content: ''; position: absolute; inset: 6px; border-radius: 50%;
            background: white; border: 2px solid var(--chip-color);
        }
        .casino-chip.small::after { inset: 4px; border: 1px solid var(--chip-color); }
        .chip-value { position: relative; z-index: 1; color: #000; font-weight: 900; text-shadow: 0 1px 2px rgba(255,255,255,0.5); }
        .chip-selected { box-shadow: 0 0 0 4px #ffd700, 0 4px 8px rgba(0,0,0,0.4); transform: scale(1.15); }
        .felt-green { background: linear-gradient(135deg, #0d5c0d 0%, #1a8b1a 50%, #0d5c0d 100%); }
        .bet-box {
            border: 2px solid #ffd700; background: rgba(255, 255, 255, 0.05);
            position: relative; cursor: pointer; transition: all 0.2s; padding: 4px;
        }
        .bet-box:hover { background: rgba(255, 255, 255, 0.15); border-color: #fff; }
        .bet-box.off { opacity: 0.5; border-color: #666; }
        .drop-zone {
            border: 3px dashed #ffd700; background: rgba(255, 215, 0, 0.1);
            border-radius: 10px; padding: 20px; text-align: center; transition: all 0.3s;
        }
        .drop-zone.drag-over { background: rgba(255, 215, 0, 0.3); border-color: #fff; transform: scale(1.02); }
        .die {
            background: linear-gradient(145deg, #ffffff, #f0f0f0);
            box-shadow: 0 0 0 2px #000, 2px 2px 4px rgba(0,0,0,0.3), inset -2px -2px 4px rgba(0,0,0,0.1);
            border-radius: 8px;
        }
        .die-dot { width: 10px; height: 10px; background: #000; border-radius: 50%; }
        @keyframes winPulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.1); } }
        @keyframes slideIn { from { opacity: 0; transform: translateY(-50px) scale(0.5); } to { opacity: 1; transform: translateY(0) scale(1); } }
        .win-loss-display { animation: slideIn 0.3s ease-out, winPulse 0.6s ease-in-out; }
        .puck {
            width: 45px; height: 45px; border-radius: 50%; border: 4px solid #000;
            display: flex; align-items: center; justify-content: center;
            font-weight: bold; font-size: 12px; box-shadow: 0 4px 8px rgba(0,0,0,0.4);
        }
        .puck.on { background: white; color: black; }
        .puck.off { background: black; color: white; }
        .craps-table-container { max-width: 1400px; margin: 0 auto; }
        .chip-rack {
            background: linear-gradient(135deg, #2d2d2d 0%, #1a1a1a 100%);
            border: 3px solid #8b4513; border-radius: 10px; padding: 15px;
            box-shadow: inset 0 2px 8px rgba(0,0,0,0.5);
        }
        @keyframes pulse-dot { 0%, 100% { opacity: 1; } 50% { opacity: 0.3; } }
        .online-dot { width: 10px; height: 10px; border-radius: 50%; background: #00ff00; display: inline-block; animation: pulse-dot 2s infinite; margin-right: 6px; }
        .loading-screen { display: flex; flex-direction: column; align-items: center; justify-content: center; min-height: 100vh; color: white; gap: 20px; }
        .loading-spinner { width: 50px; height: 50px; border: 4px solid rgba(255,215,0,0.3); border-top: 4px solid #ffd700; border-radius: 50%; animation: spin 1s linear infinite; }
        @keyframes spin { to { transform: rotate(360deg); } }
    </style>
</head>
<body>
    <div id="root"></div>
    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;

        const TABLE_KEY = 'craps-table-v2';

        const CrapsGame = () => {
          const [gameState, setGameState] = useState(null);
          const [playerId, setPlayerId] = useState(null);
          const [playerName, setPlayerName] = useState('');
          const [selectedDenomination, setSelectedDenomination] = useState(null);
          const [isRolling, setIsRolling] = useState(false);
          const [diceValues, setDiceValues] = useState({ die1: 1, die2: 1 });
          const [showJoinModal, setShowJoinModal] = useState(true);
          const [message, setMessage] = useState('');
          const [dealerCall, setDealerCall] = useState('');
          const [winLossDisplay, setWinLossDisplay] = useState(null);
          const [isDraggingChip, setIsDraggingChip] = useState(false);
          const [draggedBetType, setDraggedBetType] = useState(null);
          const [isLoading, setIsLoading] = useState(true);
          const [connectionStatus, setConnectionStatus] = useState('connecting');
          const [lastRollId, setLastRollId] = useState(null);
          const rollLockRef = useRef(false);
          const playerIdRef = useRef(null);

          const CHIP_VALUES = [
            { value: 1, color: '#ffffff', name: 'White' },
            { value: 5, color: '#ff0000', name: 'Red' },
            { value: 10, color: '#0066cc', name: 'Blue' },
            { value: 25, color: '#00aa00', name: 'Green' },
            { value: 50, color: '#ff6600', name: 'Orange' }
          ];
          const TABLE_MIN = 15, PROP_MIN = 1, STARTING_CHIPS = 250, MAX_PLAYERS = 6;

          // === SHARED STORAGE LAYER ===
          const loadFromServer = async () => {
            try {
              const result = await window.storage.get(TABLE_KEY, true);
              if (result && result.value) {
                const state = JSON.parse(result.value);
                setGameState(state);
                setConnectionStatus('connected');
                if (state.lastDice) setDiceValues(state.lastDice);
                if (state.lastDealerCall) setDealerCall(state.lastDealerCall);
                // Detect new rolls from other players
                if (state.rollId && state.rollId !== lastRollId) {
                  setLastRollId(state.rollId);
                  if (state.lastRollResult && playerIdRef.current && state.lastRollShooter !== playerIdRef.current) {
                    const myNet = (state.lastRollResult.payouts?.[playerIdRef.current] || 0) - (state.lastRollResult.losses?.[playerIdRef.current] || 0);
                    if (myNet > 0) { setWinLossDisplay({ playerId: playerIdRef.current, amount: myNet, type: 'win' }); setTimeout(() => setWinLossDisplay(null), 3000); }
                    else if (myNet < 0) { setWinLossDisplay({ playerId: playerIdRef.current, amount: Math.abs(myNet), type: 'loss' }); setTimeout(() => setWinLossDisplay(null), 3000); }
                    if (state.lastRollMessage) setMessage(state.lastRollMessage);
                  }
                }
                return state;
              }
              return null;
            } catch (e) {
              console.error('Load error:', e);
              setConnectionStatus('error');
              return null;
            }
          };

          const saveToServer = async (newState) => {
            try {
              const result = await window.storage.set(TABLE_KEY, JSON.stringify(newState), true);
              if (result) { setGameState(newState); setConnectionStatus('connected'); return true; }
              setConnectionStatus('error');
              return false;
            } catch (e) {
              console.error('Save error:', e);
              setConnectionStatus('error');
              return false;
            }
          };

          const getFreshState = async () => {
            const state = await loadFromServer();
            return state || gameState;
          };

          // Init: load or create table
          useEffect(() => {
            const init = async () => {
              setIsLoading(true);
              try {
                let state = await loadFromServer();
                if (!state) {
                  const newGame = initializeGame();
                  await saveToServer(newGame);
                  state = newGame;
                }
                setGameState(state);
                // Check if player already exists
                const storedPid = sessionStorage.getItem('craps-player-id');
                if (storedPid && state.players.find(p => p.id === storedPid)) {
                  setPlayerId(storedPid);
                  playerIdRef.current = storedPid;
                  setShowJoinModal(false);
                }
              } catch (e) {
                console.error('Init error:', e);
                const newGame = initializeGame();
                setGameState(newGame);
              }
              setIsLoading(false);
            };
            init();
          }, []);

          // Poll for updates
          useEffect(() => {
            const interval = setInterval(() => {
              if (!rollLockRef.current) loadFromServer();
            }, 1500);
            return () => clearInterval(interval);
          }, [lastRollId]);

          // Heartbeat: keep player alive
          useEffect(() => {
            if (!playerId) return;
            const heartbeat = setInterval(async () => {
              const fs = await getFreshState();
              if (!fs) return;
              const now = Date.now();
              const updatedPlayers = fs.players.map(p => p.id === playerId ? { ...p, lastSeen: now } : p);
              // Remove players not seen in 5 minutes
              const activePlayers = updatedPlayers.filter(p => (now - (p.lastSeen || p.joinedAt)) < 300000);
              const removedIds = updatedPlayers.filter(p => !activePlayers.find(a => a.id === p.id)).map(p => p.id);
              if (removedIds.length > 0 || updatedPlayers.length !== fs.players.length) {
                const activeOrder = (fs.playerOrder || []).filter(pid => activePlayers.find(p => p.id === pid));
                const newBets = { ...fs.bets };
                const newCB = { ...(fs.comeBets || {}) };
                const newDCB = { ...(fs.dontComeBets || {}) };
                removedIds.forEach(rid => { delete newBets[rid]; delete newCB[rid]; delete newDCB[rid]; });
                await saveToServer({ ...fs, players: activePlayers, playerOrder: activeOrder, bets: newBets, comeBets: newCB, dontComeBets: newDCB,
                  currentShooter: fs.currentShooter >= activeOrder.length ? 0 : fs.currentShooter });
              } else {
                await saveToServer({ ...fs, players: updatedPlayers });
              }
            }, 30000);
            return () => clearInterval(heartbeat);
          }, [playerId]);

          const initializeGame = () => ({
            players: [], playerOrder: [], currentShooter: 0, point: null,
            phase: 'comeout', lastDice: null, lastTotal: null, lastDealerCall: '',
            bets: {}, comeBets: {}, dontComeBets: {}, gameId: Date.now(),
            rollId: null, lastRollResult: null, lastRollMessage: '', lastRollShooter: null
          });

          const getDealerCall = (total, phase, point, die1, die2) => {
            const isHard = die1 === die2;
            const calls = {
              2: ["Snake eyes!", "Craps, two!", "Aces!"],
              3: ["Craps, three!", "Ace deuce!", "Craps!"],
              4: isHard ? ["Hard four!", "Little Joe from Kokomo!"] : ["Easy four!", "Four, easy!"],
              5: ["Five, no field!", "Fever five!"],
              6: isHard ? ["Hard six!", "Six the hard way!"] : ["Easy six!", "Six, no field!"],
              7: phase === 'comeout' ? ["Seven, winner seven!", "Front line winner!", "Pay the line!"] : ["Seven out, line away!", "Seven out!", "Take the don'ts!"],
              8: isHard ? ["Hard eight!", "Eight the hard way!"] : ["Easy eight!", "Eight, no field!"],
              9: ["Nine, center field!", "Nina!"],
              10: isHard ? ["Hard ten!", "Big Dick!"] : ["Easy ten!", "Ten, easy!"],
              11: ["Yo-leven!", "Yo!", "Eleven, front line winner!"],
              12: ["Boxcars!", "Craps, twelve!", "Midnight!"]
            };
            const options = calls[total] || [total + '!'];
            return options[Math.floor(Math.random() * options.length)];
          };

          const joinGame = async () => {
            if (!playerName.trim()) { showMessage('Please enter a name'); return; }
            const fs = await getFreshState();
            if (!fs) { showMessage('Connection error, try again'); return; }
            if (fs.players.length >= MAX_PLAYERS) { showMessage('Table is full (6 players max)'); return; }
            const newPlayerId = 'player_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            const newPlayer = { id: newPlayerId, name: playerName.trim(), chips: STARTING_CHIPS, joinedAt: Date.now(), lastSeen: Date.now() };
            const updatedGame = {
              ...fs, players: [...fs.players, newPlayer],
              playerOrder: [...(fs.playerOrder || []), newPlayerId],
              bets: { ...fs.bets, [newPlayerId]: {} },
              comeBets: { ...(fs.comeBets || {}), [newPlayerId]: [] },
              dontComeBets: { ...(fs.dontComeBets || {}), [newPlayerId]: [] }
            };
            const saved = await saveToServer(updatedGame);
            if (saved) {
              setPlayerId(newPlayerId);
              playerIdRef.current = newPlayerId;
              sessionStorage.setItem('craps-player-id', newPlayerId);
              setShowJoinModal(false);
              showMessage('Welcome to the table, ' + playerName + '!');
            } else { showMessage('Failed to join, try again'); }
          };

          const rebuy = async () => {
            const fs = await getFreshState();
            if (!fs) return;
            const up = fs.players.map(p => p.id === playerId ? { ...p, chips: p.chips + STARTING_CHIPS } : p);
            await saveToServer({ ...fs, players: up });
            showMessage('Added $' + STARTING_CHIPS + ' to your stack');
          };

          const getMaxOdds = (point, bet) => {
            if (point === 4 || point === 10) return bet * 3;
            if (point === 5 || point === 9) return bet * 4;
            if (point === 6 || point === 8) return bet * 5;
            return 0;
          };

          const placeBet = async (betType, betLabel, amount) => {
            if (!selectedDenomination && !amount) { showMessage('Select a chip denomination first'); return; }
            const betAmount = amount || selectedDenomination;
            const fs = await getFreshState();
            if (!fs) { showMessage('Connection error'); return; }
            const player = fs.players.find(p => p.id === playerId);
            if (!player) return;
            if (player.chips < betAmount) { showMessage('Not enough chips'); return; }
            if (betType === 'passodds' && fs.point) {
              const plb = (fs.bets[playerId]?.pass || 0);
              if (plb === 0) { showMessage('Need a Pass Line bet first'); return; }
              const co = (fs.bets[playerId]?.passodds || 0), mo = getMaxOdds(fs.point, plb);
              if (co + betAmount > mo) { showMessage('Max odds: ' + (mo/plb) + 'x ($' + mo + ')'); return; }
            }
            if (betType === 'dontpassodds' && fs.point) {
              const dpb = (fs.bets[playerId]?.dontpass || 0);
              if (dpb === 0) { showMessage("Need a Don't Pass bet first"); return; }
              const co = (fs.bets[playerId]?.dontpassodds || 0), mo = getMaxOdds(fs.point, dpb);
              if (co + betAmount > mo) { showMessage('Max odds exceeded'); return; }
            }
            if (['pass','dontpass'].includes(betType) && betAmount < TABLE_MIN) { showMessage('Minimum $' + TABLE_MIN); return; }
            if (['come','dontcome'].includes(betType) && betAmount < TABLE_MIN) { showMessage('Minimum $' + TABLE_MIN); return; }
            if (betAmount < PROP_MIN) { showMessage('Minimum $' + PROP_MIN); return; }
            if (fs.phase === 'point' && ['pass','dontpass'].includes(betType)) {
              const cb = fs.bets[playerId] || {};
              if (!cb[betType]) { showMessage("Can only bet Pass/Don't Pass on come out roll"); return; }
            }
            if (['come','dontcome'].includes(betType) && fs.phase !== 'point') { showMessage("Come/Don't Come only during point phase"); return; }
            const up = fs.players.map(p => p.id === playerId ? { ...p, chips: p.chips - betAmount } : p);
            const cb = fs.bets[playerId] || {};
            const ub = { ...fs.bets, [playerId]: { ...cb, [betType]: (cb[betType] || 0) + betAmount } };
            await saveToServer({ ...fs, players: up, bets: ub });
            showMessage('Placed $' + betAmount + ' on ' + betLabel);
          };

          const removeBet = async (betType) => {
            const fs = await getFreshState();
            if (!fs) return;
            if (['pass','dontpass'].includes(betType) && fs.phase === 'point') { showMessage("Can't remove contract bets"); return; }
            const cb = fs.bets[playerId] || {};
            const ba = cb[betType];
            if (!ba) return;
            const up = fs.players.map(p => p.id === playerId ? { ...p, chips: p.chips + ba } : p);
            const { [betType]: removed, ...rest } = cb;
            await saveToServer({ ...fs, players: up, bets: { ...fs.bets, [playerId]: rest } });
            showMessage('Removed $' + ba + ' bet');
          };

          const pullAllBets = async () => {
            const fs = await getFreshState();
            if (!fs) return;
            const cb = fs.bets[playerId] || {};
            let pullable = { ...cb }, kept = {};
            if (fs.phase === 'point') {
              if (cb.pass) { kept.pass = cb.pass; delete pullable.pass; }
              if (cb.dontpass) { kept.dontpass = cb.dontpass; delete pullable.dontpass; }
            }
            const total = Object.values(pullable).reduce((s, b) => s + b, 0);
            if (total === 0) { showMessage('No removable bets'); return; }
            const up = fs.players.map(p => p.id === playerId ? { ...p, chips: p.chips + total } : p);
            await saveToServer({ ...fs, players: up, bets: { ...fs.bets, [playerId]: kept } });
            showMessage('Pulled bets: $' + total);
          };

          const placePresetBet = async (preset) => {
            const fs = await getFreshState();
            if (!fs) return;
            const player = fs.players.find(p => p.id === playerId);
            if (!player || !selectedDenomination) { showMessage('Select a chip denomination first'); return; }
            const csid = fs.playerOrder[fs.currentShooter];
            const isCS = playerId === csid, point = fs.point;
            const myBets = fs.bets[playerId] || {};
            const hasPL = myBets.pass > 0;
            let btp = [];
            const skip = (n) => (isCS || hasPL) && n === point;
            if (preset === 'inside') { [5,6,8,9].forEach(n => { if (!skip(n)) btp.push({ type: 'place'+n }); }); }
            else if (preset === 'outside') { [4,10].forEach(n => { if (!skip(n)) btp.push({ type: 'buy'+n }); }); }
            else if (preset === 'across') { [4,5,6,8,9,10].forEach(n => { if (!skip(n)) btp.push({ type: (n===4||n===10?'buy':'place')+n }); }); }
            if (btp.length === 0) { showMessage('No bets to place'); return; }
            const tc = selectedDenomination * btp.length;
            if (player.chips < tc) { showMessage('Need $' + tc); return; }
            const up = fs.players.map(p => p.id === playerId ? { ...p, chips: p.chips - tc } : p);
            const nb = { ...myBets };
            btp.forEach(b => { nb[b.type] = (nb[b.type] || 0) + selectedDenomination; });
            await saveToServer({ ...fs, players: up, bets: { ...fs.bets, [playerId]: nb } });
            showMessage('Placed ' + btp.length + ' ' + preset.toUpperCase() + ' bets ($' + tc + ')');
          };

          const getTotalBetsOnTable = () => {
            if (!playerId || !gameState) return 0;
            const mb = gameState.bets[playerId] || {};
            let t = Object.values(mb).reduce((s, b) => s + b, 0);
            ((gameState.comeBets || {})[playerId] || []).forEach(cb => { t += cb.amount; });
            ((gameState.dontComeBets || {})[playerId] || []).forEach(cb => { t += cb.amount; });
            return t;
          };

          const rollDice = async () => {
            if (isRolling || rollLockRef.current) return;
            const fs = await getFreshState();
            if (!fs) return;
            const sid = fs.playerOrder[fs.currentShooter];
            if (sid !== playerId) { showMessage('Not your turn to shoot'); return; }
            rollLockRef.current = true;
            setIsRolling(true); setMessage(''); setDealerCall('');
            for (let i = 0; i < 10; i++) {
              setDiceValues({ die1: Math.floor(Math.random()*6)+1, die2: Math.floor(Math.random()*6)+1 });
              await new Promise(r => setTimeout(r, 80));
            }
            const die1 = Math.floor(Math.random()*6)+1, die2 = Math.floor(Math.random()*6)+1, total = die1+die2;
            setDiceValues({ die1, die2 });
            const call = getDealerCall(total, fs.phase, fs.point, die1, die2);
            setDealerCall(call);
            await new Promise(r => setTimeout(r, 500));
            await processRoll(fs, die1, die2, total, call);
            setIsRolling(false);
            rollLockRef.current = false;
          };

          const processRoll = async (gs, die1, die2, total, call) => {
            const rollId = Date.now() + '_' + Math.random().toString(36).substr(2,6);
            let ug = { ...gs, lastDice: { die1, die2 }, lastTotal: total, lastDealerCall: call,
              comeBets: JSON.parse(JSON.stringify(gs.comeBets || {})),
              dontComeBets: JSON.parse(JSON.stringify(gs.dontComeBets || {})),
              rollId: rollId, lastRollShooter: playerId
            };
            const pay = {}, loss = {};
            let msgs = [], sevenOut = false;
            gs.players.forEach(p => { pay[p.id] = 0; loss[p.id] = 0; });

            // ONE-ROLL BETS
            gs.players.forEach(p => {
              const b = gs.bets[p.id] || {};
              if (b.field) {
                if ([2,3,4,9,10,11,12].includes(total)) { pay[p.id] += (total===2||total===12) ? b.field*2 : b.field; }
                else { loss[p.id] += b.field; }
              }
              if (b.horn) {
                if ([2,3,11,12].includes(total)) { const hb=b.horn/4; pay[p.id]+=(total===2||total===12)?hb*30:hb*15; loss[p.id]+=hb*3; }
                else { loss[p.id] += b.horn; }
              }
              if (b.ce) {
                if ([2,3,12].includes(total)) { const h=b.ce/2; pay[p.id]+=h*7; loss[p.id]+=h; }
                else if (total===11) { const h=b.ce/2; pay[p.id]+=h*15; loss[p.id]+=h; }
                else { loss[p.id]+=b.ce; }
              }
            });
            ug.bets = clearBets(gs.bets, ['field','horn','ce']);

            // PASS/DON'T PASS
            if (gs.phase === 'comeout') {
              if (total===7||total===11) {
                msgs.push('Natural! Pass wins');
                gs.players.forEach(p => { const b=gs.bets[p.id]||{}; if(b.pass) pay[p.id]+=b.pass; if(b.dontpass) loss[p.id]+=b.dontpass; });
                ug.bets = clearBets(ug.bets, ['pass','dontpass']);
              } else if ([2,3,12].includes(total)) {
                msgs.push('Craps!');
                gs.players.forEach(p => { const b=gs.bets[p.id]||{}; if(b.pass) loss[p.id]+=b.pass; if(b.dontpass&&total!==12) pay[p.id]+=b.dontpass; });
                ug.bets = clearBets(ug.bets, total===12?['pass']:['pass','dontpass']);
              } else { msgs.push('Point is '+total); ug.point=total; ug.phase='point'; }
            } else {
              if (total===7) {
                sevenOut=true; msgs.push('Seven out!');
                gs.players.forEach(p => {
                  const b=gs.bets[p.id]||{};
                  if(b.pass) loss[p.id]+=b.pass; if(b.passodds) loss[p.id]+=b.passodds;
                  if(b.dontpass) pay[p.id]+=b.dontpass; if(b.dontpassodds) pay[p.id]+=getDPOddsWin(gs.point,b.dontpassodds);
                  [4,5,6,8,9,10].forEach(n=>{if(b['place'+n])loss[p.id]+=b['place'+n];if(b['buy'+n])loss[p.id]+=b['buy'+n];});
                  [4,6,8,10].forEach(n=>{if(b['hard'+n])loss[p.id]+=b['hard'+n];});
                  if(b.come) pay[p.id]+=b.come; if(b.dontcome) loss[p.id]+=b.dontcome;
                  (ug.comeBets[p.id]||[]).forEach(cb=>{loss[p.id]+=cb.amount;}); ug.comeBets[p.id]=[];
                  (ug.dontComeBets[p.id]||[]).forEach(cb=>{pay[p.id]+=cb.amount;}); ug.dontComeBets[p.id]=[];
                });
                ug.point=null; ug.phase='comeout';
                ug.currentShooter=(gs.currentShooter+1)%gs.playerOrder.length;
                ug.bets={};
              } else if (total===gs.point) {
                msgs.push('Point made! Pass wins');
                gs.players.forEach(p => {
                  const b=gs.bets[p.id]||{};
                  if(b.pass)pay[p.id]+=b.pass; if(b.passodds)pay[p.id]+=getOddsWin(gs.point,b.passodds);
                  if(b.dontpass)loss[p.id]+=b.dontpass; if(b.dontpassodds)loss[p.id]+=b.dontpassodds;
                });
                const keep={};
                gs.players.forEach(p=>{const b=gs.bets[p.id]||{};keep[p.id]={};
                  [4,5,6,8,9,10].forEach(n=>{if(b['place'+n])keep[p.id]['place'+n]=b['place'+n];if(b['buy'+n])keep[p.id]['buy'+n]=b['buy'+n];});
                  [4,6,8,10].forEach(n=>{if(b['hard'+n])keep[p.id]['hard'+n]=b['hard'+n];});
                  if(b.come)keep[p.id].come=b.come;if(b.dontcome)keep[p.id].dontcome=b.dontcome;
                });
                ug.point=null; ug.phase='comeout'; ug.bets=keep;
              }
            }

            // COME/DON'T COME
            if (gs.phase==='point'&&!sevenOut) {
              gs.players.forEach(p=>{
                const b=gs.bets[p.id]||{};
                if(b.come){
                  if(total===7||total===11){pay[p.id]+=b.come;if(ug.bets[p.id])delete ug.bets[p.id].come;}
                  else if([2,3,12].includes(total)){loss[p.id]+=b.come;if(ug.bets[p.id])delete ug.bets[p.id].come;}
                  else{if(!ug.comeBets[p.id])ug.comeBets[p.id]=[];const ex=ug.comeBets[p.id].find(x=>x.number===total);
                    if(ex)ex.amount+=b.come;else ug.comeBets[p.id].push({number:total,amount:b.come});
                    if(ug.bets[p.id])delete ug.bets[p.id].come;msgs.push('Come bet to '+total);}
                }
                if(b.dontcome){
                  if(total===7||total===11){loss[p.id]+=b.dontcome;if(ug.bets[p.id])delete ug.bets[p.id].dontcome;}
                  else if(total===2||total===3){pay[p.id]+=b.dontcome;if(ug.bets[p.id])delete ug.bets[p.id].dontcome;}
                  else if(total===12){/* push */}
                  else{if(!ug.dontComeBets[p.id])ug.dontComeBets[p.id]=[];const ex=ug.dontComeBets[p.id].find(x=>x.number===total);
                    if(ex)ex.amount+=b.dontcome;else ug.dontComeBets[p.id].push({number:total,amount:b.dontcome});
                    if(ug.bets[p.id])delete ug.bets[p.id].dontcome;}
                }
                (ug.comeBets[p.id]||[]).slice().forEach(cb=>{if(total===cb.number){pay[p.id]+=cb.amount;ug.comeBets[p.id]=ug.comeBets[p.id].filter(x=>x!==cb);}});
                (ug.dontComeBets[p.id]||[]).slice().forEach(cb=>{if(total===cb.number){loss[p.id]+=cb.amount;ug.dontComeBets[p.id]=ug.dontComeBets[p.id].filter(x=>x!==cb);}});
              });
            }

            // PLACE BETS
            if(gs.phase==='point'&&!sevenOut&&[4,5,6,8,9,10].includes(total)){
              gs.players.forEach(p=>{const b=gs.bets[p.id]||{};if(b['place'+total])pay[p.id]+=getPlaceWin(total,b['place'+total]);});
            }
            // BUY BETS with 5% vig
            if(gs.phase==='point'&&!sevenOut&&[4,5,6,8,9,10].includes(total)){
              gs.players.forEach(p=>{const b=gs.bets[p.id]||{};if(b['buy'+total]){const tw=getBuyWin(total,b['buy'+total]);pay[p.id]+=(tw-Math.ceil(tw*0.05));}});
            }
            // HARDWAYS
            if(gs.phase==='point'&&!sevenOut){
              [4,6,8,10].forEach(hn=>{
                if(total===hn&&die1===die2){gs.players.forEach(p=>{const b=gs.bets[p.id]||{};if(b['hard'+hn])pay[p.id]+=getHardwayWin(hn,b['hard'+hn]);});}
                else if(total===hn&&die1!==die2){gs.players.forEach(p=>{const b=gs.bets[p.id]||{};if(b['hard'+hn])loss[p.id]+=b['hard'+hn];});ug.bets=clearBets(ug.bets,['hard'+hn]);}
              });
            }

            ug.players = gs.players.map(p=>({...p,chips:p.chips+(pay[p.id]||0)}));
            ug.lastRollResult = { payouts: pay, losses: loss };
            ug.lastRollMessage = msgs.join(' \u2022 ');
            await saveToServer(ug);
            setLastRollId(rollId);

            const myNet = (pay[playerId]||0) - (loss[playerId]||0);
            if(myNet>0){setWinLossDisplay({playerId,amount:myNet,type:'win'});setTimeout(()=>setWinLossDisplay(null),3000);}
            else if(myNet<0){setWinLossDisplay({playerId,amount:Math.abs(myNet),type:'loss'});setTimeout(()=>setWinLossDisplay(null),3000);}
            if(msgs.length>0) showMessage(msgs.join(' \u2022 '));
          };

          const clearBets = (bets, types) => {
            const nb={};Object.keys(bets).forEach(pid=>{nb[pid]={};Object.keys(bets[pid]||{}).forEach(bt=>{if(!types.includes(bt))nb[pid][bt]=bets[pid][bt];});});return nb;
          };
          const getOddsWin=(pt,bet)=>{if(pt===4||pt===10)return bet*2;if(pt===5||pt===9)return bet*1.5;if(pt===6||pt===8)return bet*1.2;return 0;};
          const getDPOddsWin=(pt,bet)=>{if(pt===4||pt===10)return bet*0.5;if(pt===5||pt===9)return bet*(2/3);if(pt===6||pt===8)return bet*(5/6);return 0;};
          const getPlaceWin=(n,bet)=>{if(n===4||n===10)return Math.floor(bet*(9/5));if(n===5||n===9)return Math.floor(bet*(7/5));if(n===6||n===8)return Math.floor(bet*(7/6));return 0;};
          const getBuyWin=(n,bet)=>{if(n===4||n===10)return bet*2;if(n===5||n===9)return bet*1.5;if(n===6||n===8)return bet*1.2;return 0;};
          const getHardwayWin=(n,bet)=>{if(n===4||n===10)return bet*7;if(n===6||n===8)return bet*9;return 0;};
          const showMessage=(msg)=>{setMessage(msg);setTimeout(()=>setMessage(''),4000);};
          const getChipForAmount=(amount)=>{for(let i=CHIP_VALUES.length-1;i>=0;i--){if(amount>=CHIP_VALUES[i].value)return CHIP_VALUES[i];}return CHIP_VALUES[0];};

          const CasinoChip=({chipInfo,onClick,disabled,selected,small=false,draggable:isDraggable=false,onDragStart:onDS,onDragEnd:onDE})=>{
            const[isDragging,setIsDragging]=useState(false);
            return(<div className={'casino-chip '+(small?'small ':'')+( selected?'chip-selected ':'')+(isDragging?'dragging':'')}
              style={{'--chip-color':chipInfo.color,opacity:disabled?0.5:1,cursor:disabled?'not-allowed':(isDraggable?'grab':'pointer')}}
              onClick={()=>!disabled&&onClick&&onClick(chipInfo)} draggable={isDraggable&&!disabled}
              onDragStart={(e)=>{if(isDraggable&&!disabled&&onDS){setIsDragging(true);onDS(e);}}}
              onDragEnd={(e)=>{setIsDragging(false);if(onDE)onDE(e);}}
            ><span className="chip-value">${chipInfo.value}</span></div>);
          };

          const Dice=({value})=>{
            const dp={1:[[50,50]],2:[[25,25],[75,75]],3:[[25,25],[50,50],[75,75]],4:[[25,25],[25,75],[75,25],[75,75]],5:[[25,25],[25,75],[50,50],[75,25],[75,75]],6:[[25,25],[25,50],[25,75],[75,25],[75,50],[75,75]]};
            return(<div className="die" style={{width:80,height:80,position:'relative'}}>{dp[value].map((pos,i)=>(<div key={i} className="die-dot" style={{position:'absolute',left:pos[0]+'%',top:pos[1]+'%',transform:'translate(-50%,-50%)'}}/>))}</div>);
          };

          const BetBox=({betType,label,className='',style={},isOff=false})=>{
            const allBets=gameState?.bets||{};
            return(<div onClick={()=>selectedDenomination&&placeBet(betType,label)} className={'bet-box '+className+(isOff?' off':'')}
              style={{...style,minHeight:'50px',display:'flex',alignItems:'center',justifyContent:'center'}}>
              <div style={{textAlign:'center',color:'#ffd700',fontWeight:'bold',fontSize:'14px',textShadow:'1px 1px 2px #000',position:'relative',zIndex:1}}>
                {label}{isOff&&<div style={{fontSize:'10px',color:'#999'}}>OFF</div>}
              </div>
              <div style={{position:'absolute',top:'50%',left:'50%',transform:'translate(-50%,-50%)',display:'flex',flexWrap:'wrap',gap:'6px',zIndex:2,alignItems:'center',justifyContent:'center'}}>
                {gameState?.players.map(player=>{
                  const pb=allBets[player.id]?.[betType]; if(!pb)return null;
                  const isMe=player.id===playerId, ci=getChipForAmount(pb);
                  return(<div key={player.id} style={{textAlign:'center',display:'flex',alignItems:'center',gap:'4px',background:isMe?'rgba(255,215,0,0.4)':'rgba(0,0,0,0.3)',padding:'4px 6px',borderRadius:'6px',border:isMe?'2px solid #ffd700':'1px solid rgba(255,255,255,0.2)'}}>
                    <CasinoChip chipInfo={ci} onClick={()=>{}} disabled={false} small={true} draggable={isMe}
                      onDragStart={(e)=>{setIsDraggingChip(true);setDraggedBetType(betType);e.dataTransfer.effectAllowed='move';}}
                      onDragEnd={()=>{setIsDraggingChip(false);setDraggedBetType(null);}}/>
                    <div style={{display:'flex',flexDirection:'column',alignItems:'flex-start'}}>
                      <div style={{fontSize:'10px',color:'#fff',fontWeight:'bold',textShadow:'1px 1px 2px #000',lineHeight:'1.2'}}>{player.name.substring(0,6)}</div>
                      <div style={{fontSize:'12px',color:'#ffd700',fontWeight:'bold',textShadow:'1px 1px 2px #000',lineHeight:'1.2'}}>${pb}</div>
                    </div>
                  </div>);
                })}
              </div>
            </div>);
          };

          const ComeBetDisplay=({number})=>{
            const cb=(gameState?.comeBets||{}),dcb=(gameState?.dontComeBets||{});
            const bets=[];
            gameState?.players.forEach(p=>{
              (cb[p.id]||[]).filter(x=>x.number===number).forEach(x=>bets.push({player:p,amount:x.amount,type:'come'}));
              (dcb[p.id]||[]).filter(x=>x.number===number).forEach(x=>bets.push({player:p,amount:x.amount,type:'dontcome'}));
            });
            if(bets.length===0)return null;
            return(<div style={{display:'flex',flexWrap:'wrap',gap:'3px',justifyContent:'center',marginTop:'2px'}}>
              {bets.map((b,i)=>(<div key={i} style={{fontSize:'9px',padding:'2px 4px',borderRadius:'4px',
                background:b.type==='come'?'rgba(0,255,0,0.3)':'rgba(255,0,0,0.3)',
                border:b.player.id===playerId?'1px solid #ffd700':'1px solid rgba(255,255,255,0.2)',
                color:'#fff',fontWeight:'bold'}}>{b.type==='come'?'C':'DC'} ${b.amount} {b.player.name.substring(0,4)}</div>))}
            </div>);
          };

          if(isLoading) return(<div className="loading-screen"><div className="loading-spinner"></div><div style={{fontSize:'24px',color:'#ffd700',fontWeight:'bold'}}>üé≤ Connecting to table...</div></div>);
          if(!gameState) return(<div className="loading-screen"><div style={{fontSize:'24px',color:'#ff6666'}}>Failed to connect. Please refresh.</div></div>);

          const currentPlayer=gameState.players.find(p=>p.id===playerId);
          const shooterId=gameState.playerOrder?.[gameState.currentShooter];
          const isShooter=currentPlayer&&shooterId===playerId;
          const shooter=gameState.players.find(p=>p.id===shooterId);
          const currentShooterName=shooter?.name||'Waiting...';
          const betsAreOff=gameState.phase==='comeout';
          const totalOnTable=getTotalBetsOnTable();
          const isAboveStarting=currentPlayer&&currentPlayer.chips>=STARTING_CHIPS;

          if(showJoinModal||!currentPlayer){
            return(
              <div style={{display:'flex',alignItems:'center',justifyContent:'center',minHeight:'100vh',padding:'20px'}}>
                <div style={{background:'linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%)',padding:'40px',borderRadius:'20px',boxShadow:'0 10px 40px rgba(0,0,0,0.5)',maxWidth:'500px',width:'100%',border:'3px solid #ffd700'}}>
                  <h1 style={{color:'#ffd700',fontSize:'36px',fontWeight:'bold',marginBottom:'10px',textAlign:'center',textShadow:'2px 2px 4px #000'}}>üé≤ VEGAS CRAPS üé≤</h1>
                  <div style={{textAlign:'center',marginBottom:'5px'}}><span className="online-dot"></span><span style={{color:'#00ff00',fontSize:'14px'}}>ONLINE MULTIPLAYER</span></div>
                  <p style={{color:'#fff',textAlign:'center',marginBottom:'30px'}}>Join the table and play with others in real-time!</p>
                  <input type="text" placeholder="Enter your name" value={playerName}
                    onChange={(e)=>setPlayerName(e.target.value)}
                    onKeyDown={(e)=>e.key==='Enter'&&joinGame()}
                    style={{width:'100%',padding:'15px',border:'3px solid #ffd700',borderRadius:'10px',marginBottom:'20px',fontSize:'18px',background:'#fff'}}
                    maxLength={15} autoFocus/>
                  <button onClick={joinGame} disabled={!playerName.trim()||gameState.players.length>=MAX_PLAYERS}
                    style={{width:'100%',background:'linear-gradient(135deg, #ff0000 0%, #cc0000 100%)',color:'#fff',padding:'15px',borderRadius:'10px',fontSize:'20px',fontWeight:'bold',border:'none',cursor:'pointer',boxShadow:'0 4px 8px rgba(0,0,0,0.3)'}}>
                    {gameState.players.length>=MAX_PLAYERS?'TABLE FULL (6/6)':'JOIN TABLE ('+gameState.players.length+'/6)'}
                  </button>
                  <div style={{marginTop:'30px',color:'#fff',fontSize:'14px'}}>
                    <p style={{fontWeight:'bold',marginBottom:'10px',color:'#ffd700'}}>Table Rules:</p>
                    <ul style={{listStyle:'none',lineHeight:'1.8'}}>
                      <li>üí∞ Starting chips: $250</li><li>üéØ Table minimum: $15</li><li>üé≤ Prop minimum: $1</li>
                      <li>üë• Max players: 6</li><li>üìä Odds: 3-4-5x</li><li>üíµ Buy bets: 5% vig on win</li>
                    </ul>
                  </div>
                  {gameState.players.length>0&&(
                    <div style={{marginTop:'20px',padding:'15px',background:'rgba(255,215,0,0.1)',borderRadius:'10px',border:'1px solid #ffd700'}}>
                      <p style={{fontWeight:'bold',fontSize:'14px',marginBottom:'10px',color:'#ffd700'}}>Players at table:</p>
                      {gameState.playerOrder?.map((pid,idx)=>{const p=gameState.players.find(pl=>pl.id===pid);if(!p)return null;
                        return <div key={p.id} style={{color:'#fff',fontSize:'14px',marginBottom:'5px'}}>{idx===gameState.currentShooter&&'üé≤ '}üé∞ {p.name} (${p.chips})</div>;
                      })}
                    </div>
                  )}
                </div>
              </div>
            );
          }

          const handleDZOver=(e)=>{e.preventDefault();e.currentTarget.classList.add('drag-over');};
          const handleDZLeave=(e)=>{e.currentTarget.classList.remove('drag-over');};
          const handleDZDrop=(e)=>{e.preventDefault();e.currentTarget.classList.remove('drag-over');if(draggedBetType){removeBet(draggedBetType);setDraggedBetType(null);}};

          return(
            <div style={{minHeight:'100vh',padding:'10px',background:'linear-gradient(135deg, #1a1a2e 0%, #0f3460 100%)',position:'relative'}}>
              {winLossDisplay&&winLossDisplay.playerId===playerId&&(
                <div className="win-loss-display" style={{position:'fixed',top:'50%',left:'50%',transform:'translate(-50%,-50%)',zIndex:9999,
                  background:winLossDisplay.type==='win'?'linear-gradient(135deg, #00ff00 0%, #00aa00 100%)':'linear-gradient(135deg, #ff0000 0%, #aa0000 100%)',
                  color:'#fff',padding:'40px 60px',borderRadius:'20px',fontSize:'48px',fontWeight:'bold',textAlign:'center',
                  boxShadow:'0 10px 40px rgba(0,0,0,0.8)',border:'5px solid #ffd700',textShadow:'3px 3px 6px rgba(0,0,0,0.5)'}}>
                  {winLossDisplay.type==='win'?'+ $':'- $'}{winLossDisplay.amount}
                  <div style={{fontSize:'24px',marginTop:'10px'}}>{winLossDisplay.type==='win'?'üéâ WINNER! üéâ':'üíî LOST üíî'}</div>
                </div>
              )}
              {dealerCall&&(
                <div style={{position:'fixed',top:'20px',left:'50%',transform:'translateX(-50%)',zIndex:1000,
                  background:'linear-gradient(135deg, #000 0%, #1a1a1a 100%)',color:'#ffd700',padding:'20px 40px',borderRadius:'15px',
                  fontSize:'32px',fontWeight:'bold',textAlign:'center',boxShadow:'0 8px 24px rgba(0,0,0,0.8)',border:'3px solid #ffd700',textShadow:'2px 2px 4px #000'}}>
                  {dealerCall}
                </div>
              )}
              <div className="craps-table-container">
                <div style={{background:'linear-gradient(135deg, #000 0%, #1a1a1a 100%)',color:'#ffd700',padding:'15px',borderRadius:'10px',marginBottom:'10px',boxShadow:'0 4px 12px rgba(0,0,0,0.5)',border:'2px solid #ffd700'}}>
                  <div style={{display:'flex',justifyContent:'space-between',alignItems:'center',flexWrap:'wrap',gap:'10px'}}>
                    <div>
                      <h1 style={{fontSize:'24px',fontWeight:'bold',textShadow:'2px 2px 4px #000'}}>üé≤ VEGAS CRAPS TABLE</h1>
                      <div style={{fontSize:'12px',color:'#fff'}}><span className="online-dot"></span>LIVE ‚Ä¢ Min: $15 ‚Ä¢ Odds: 3-4-5x ‚Ä¢ Buy: 5% vig</div>
                    </div>
                    <div className="chip-rack" style={{textAlign:'center',minWidth:'200px'}}>
                      <div style={{fontSize:'14px',color:'#ffd700',marginBottom:'5px',fontWeight:'bold'}}>{currentPlayer.name}'s RACK</div>
                      <div style={{fontSize:'28px',fontWeight:'bold',color:isAboveStarting?'#00ff00':'#ff0000'}}>${currentPlayer.chips}</div>
                      <div style={{fontSize:'12px',color:'#fff',marginTop:'5px'}}>On Table: ${totalOnTable}</div>
                      {currentPlayer.chips<TABLE_MIN&&(
                        <button onClick={rebuy} style={{marginTop:'8px',background:'#ffd700',color:'#000',padding:'5px 10px',borderRadius:'5px',border:'none',fontWeight:'bold',cursor:'pointer',fontSize:'12px'}}>Rebuy +$250</button>
                      )}
                    </div>
                  </div>
                </div>

                <div style={{background:'#000',color:'#fff',padding:'15px',borderRadius:'10px',marginBottom:'10px',boxShadow:'0 4px 12px rgba(0,0,0,0.5)',border:'3px solid #ffd700'}}>
                  <div style={{display:'flex',justifyContent:'space-between',alignItems:'center',flexWrap:'wrap',gap:'10px',fontSize:'16px'}}>
                    <div style={{display:'flex',alignItems:'center',gap:'10px'}}>
                      <div className={'puck '+(gameState.phase==='comeout'?'off':'on')}>{gameState.phase==='comeout'?'OFF':'ON'}</div>
                      <div style={{fontWeight:'bold'}}>
                        {gameState.phase==='comeout'?<span style={{color:'#00ff00'}}>COME OUT ROLL</span>:
                          <span style={{color:'#fff'}}>POINT IS <span style={{color:'#ffd700',fontSize:'24px'}}>{gameState.point}</span></span>}
                      </div>
                    </div>
                    <div><span style={{fontWeight:'bold',color:'#ffd700'}}>Shooter:</span> {currentShooterName}{isShooter&&<span style={{marginLeft:'10px',color:'#ff0000'}}>üé≤ (YOU)</span>}</div>
                    {gameState.lastTotal&&<div style={{fontWeight:'bold',color:'#ffd700'}}>Last: {gameState.lastTotal}</div>}
                  </div>
                </div>

                {message&&<div style={{background:'linear-gradient(135deg, #0066ff 0%, #0044cc 100%)',color:'#fff',padding:'15px',borderRadius:'10px',marginBottom:'10px',textAlign:'center',fontWeight:'bold',boxShadow:'0 4px 12px rgba(0,102,255,0.5)'}}>{message}</div>}

                {isDraggingChip&&(
                  <div className="drop-zone" onDragOver={handleDZOver} onDragLeave={handleDZLeave} onDrop={handleDZDrop} style={{marginBottom:'10px'}}>
                    <div style={{fontSize:'20px',color:'#ffd700',fontWeight:'bold'}}>‚¨áÔ∏è Drop Chip Here to Return to Rack ‚¨áÔ∏è</div>
                  </div>
                )}

                <div className="felt-green" style={{borderRadius:'50px 50px 20px 20px',padding:'20px',border:'12px solid #8b4513',boxShadow:'0 8px 24px rgba(0,0,0,0.6), inset 0 0 30px rgba(0,0,0,0.4)',marginBottom:'10px'}}>
                  <div style={{marginBottom:'15px'}}>
                    <div style={{display:'grid',gridTemplateColumns:'1fr 1fr',gap:'10px'}}>
                      <BetBox betType="come" label="COME" style={{height:'60px',fontSize:'24px',color:'#ff0000',background:'rgba(255,255,255,0.1)'}}/>
                      <BetBox betType="dontcome" label="DON'T COME" style={{height:'60px',fontSize:'16px',background:'rgba(255,255,255,0.1)'}}/>
                    </div>
                  </div>
                  <div style={{display:'grid',gridTemplateColumns:'repeat(6, 1fr)',gap:'8px',marginBottom:'15px'}}>
                    {[4,5,6,8,9,10].map(num=>(
                      <div key={num} style={{position:'relative'}}>
                        <div style={{fontSize:num===6||num===9?'32px':'40px',fontWeight:'bold',textAlign:'center',color:'#ffd700',textShadow:'2px 2px 4px #000',marginBottom:'5px',fontStyle:num===6||num===9?'italic':'normal'}}>
                          {num===6?'six':num===9?'Nine':num}
                        </div>
                        <div style={{display:'grid',gridTemplateRows:'1fr 1fr',gap:'4px'}}>
                          <BetBox betType={'place'+num} label="PLACE" isOff={betsAreOff} style={{height:'50px',fontSize:'11px',background:gameState.point===num?'rgba(255,255,255,0.25)':'rgba(255,255,255,0.1)',border:gameState.point===num?'3px solid #fff':'2px solid #ffd700'}}/>
                          <BetBox betType={'buy'+num} label={'BUY\n(5% vig)'} isOff={betsAreOff} style={{height:'50px',fontSize:'10px',background:'rgba(100,150,255,0.2)',whiteSpace:'pre-line'}}/>
                        </div>
                        <ComeBetDisplay number={num}/>
                        {gameState.point===num&&<div className="puck on" style={{position:'absolute',top:'0px',right:'0px'}}>ON</div>}
                      </div>
                    ))}
                  </div>
                  <div style={{marginBottom:'15px'}}><BetBox betType="field" label="FIELD ‚Ä¢ 2-3-4-9-10-11-12 ‚Ä¢ Pay Double 2&12" style={{height:'60px',fontSize:'14px',background:'rgba(255,255,255,0.1)',color:'#ff0000'}}/></div>
                  <div style={{background:'rgba(0,0,0,0.4)',padding:'15px',borderRadius:'15px',marginBottom:'15px'}}>
                    <div style={{marginBottom:'12px'}}>
                      <div style={{color:'#ffd700',fontSize:'14px',fontWeight:'bold',textAlign:'center',marginBottom:'8px',textShadow:'1px 1px 2px #000'}}>HARDWAYS</div>
                      <div style={{display:'grid',gridTemplateColumns:'repeat(4, 1fr)',gap:'8px'}}>
                        {[4,6,8,10].map(num=>(<BetBox key={num} betType={'hard'+num} label={'üé≤üé≤\nHard '+num+'\n'+(num===4||num===10?'7:1':'9:1')} isOff={betsAreOff} style={{height:'70px',fontSize:'11px',background:'rgba(255,200,0,0.2)',whiteSpace:'pre-line'}}/>))}
                      </div>
                    </div>
                    <div>
                      <div style={{color:'#ffd700',fontSize:'14px',fontWeight:'bold',textAlign:'center',marginBottom:'8px',textShadow:'1px 1px 2px #000'}}>ONE ROLL BETS</div>
                      <div style={{display:'grid',gridTemplateColumns:'1fr 1fr',gap:'8px'}}>
                        <BetBox betType="horn" label={'HORN\n30:1 / 15:1'} style={{height:'60px',fontSize:'12px',background:'rgba(255,100,100,0.3)',whiteSpace:'pre-line'}}/>
                        <BetBox betType="ce" label="C & E" style={{height:'60px',fontSize:'18px',background:'rgba(255,100,100,0.3)'}}/>
                      </div>
                    </div>
                  </div>
                  {gameState.point&&(
                    <div style={{display:'grid',gridTemplateColumns:'1fr 1fr',gap:'10px'}}>
                      <BetBox betType="passodds" label="ODDS ON PASS" style={{height:'50px',background:'rgba(0,255,0,0.2)',fontSize:'13px'}}/>
                      <BetBox betType="dontpassodds" label="ODDS ON DON'T PASS" style={{height:'50px',background:'rgba(0,255,0,0.2)',fontSize:'12px'}}/>
                    </div>
                  )}
                </div>

                <div style={{background:'#fff',padding:'20px',borderRadius:'10px',marginBottom:'10px',boxShadow:'0 8px 16px rgba(0,0,0,0.4)'}}>
                  <div style={{display:'flex',justifyContent:'center',gap:'20px',marginBottom:'20px'}}><Dice value={diceValues.die1}/><Dice value={diceValues.die2}/></div>
                  {isShooter?(
                    <button onClick={rollDice} disabled={isRolling}
                      style={{width:'100%',background:isRolling?'#666':'linear-gradient(135deg, #ff0000 0%, #cc0000 100%)',color:'#fff',padding:'20px',borderRadius:'10px',fontSize:'24px',fontWeight:'bold',border:'none',cursor:isRolling?'not-allowed':'pointer',boxShadow:'0 6px 12px rgba(0,0,0,0.4)'}}>
                      {isRolling?'üé≤ ROLLING...':'üé≤ ROLL DICE'}
                    </button>
                  ):(
                    <div style={{textAlign:'center',color:'#666',padding:'20px',fontWeight:'bold',fontSize:'18px'}}>Waiting for {currentShooterName} to roll...</div>
                  )}
                </div>

                <div style={{background:'linear-gradient(135deg, #000 0%, #1a1a1a 100%)',padding:'15px',borderRadius:'10px',marginBottom:'10px',boxShadow:'0 4px 12px rgba(0,0,0,0.5)',border:'2px solid #ffd700'}}>
                  <div style={{marginBottom:'10px'}}>
                    <div style={{color:'#ffd700',fontWeight:'bold',fontSize:'14px',marginBottom:'8px'}}>Select Denomination:</div>
                    <div style={{display:'flex',gap:'10px',flexWrap:'wrap',justifyContent:'center'}}>
                      {CHIP_VALUES.map(ci=>(<CasinoChip key={ci.value} chipInfo={ci} onClick={(c)=>setSelectedDenomination(c.value)} disabled={currentPlayer.chips<ci.value} selected={selectedDenomination===ci.value}/>))}
                    </div>
                  </div>
                  <div style={{borderTop:'1px solid #ffd700',paddingTop:'10px'}}>
                    <div style={{color:'#ffd700',fontWeight:'bold',fontSize:'14px',marginBottom:'8px'}}>Quick Actions:</div>
                    <div style={{display:'flex',gap:'8px',flexWrap:'wrap',justifyContent:'center'}}>
                      <button onClick={()=>placePresetBet('inside')} disabled={!selectedDenomination} style={{background:'#000',color:'#fff',padding:'8px 16px',borderRadius:'5px',border:'2px solid #ffd700',fontWeight:'bold',cursor:'pointer',fontSize:'12px'}}>INSIDE (5,6,8,9)</button>
                      <button onClick={()=>placePresetBet('outside')} disabled={!selectedDenomination} style={{background:'#000',color:'#fff',padding:'8px 16px',borderRadius:'5px',border:'2px solid #ffd700',fontWeight:'bold',cursor:'pointer',fontSize:'12px'}}>OUTSIDE (4,10 Buy)</button>
                      <button onClick={()=>placePresetBet('across')} disabled={!selectedDenomination} style={{background:'#000',color:'#fff',padding:'8px 16px',borderRadius:'5px',border:'2px solid #ffd700',fontWeight:'bold',cursor:'pointer',fontSize:'12px'}}>ACROSS (All)</button>
                      <button onClick={pullAllBets} disabled={totalOnTable===0} style={{background:'#ff0000',color:'#fff',padding:'8px 16px',borderRadius:'5px',border:'2px solid #fff',fontWeight:'bold',cursor:'pointer',fontSize:'12px'}}>PULL BETS DOWN</button>
                      <button onClick={()=>setSelectedDenomination(null)} style={{background:'#666',color:'#fff',padding:'8px 16px',borderRadius:'5px',border:'none',fontWeight:'bold',cursor:'pointer',fontSize:'12px'}}>Clear Selection</button>
                    </div>
                  </div>
                </div>

                <div className="felt-green" style={{borderRadius:'20px',padding:'15px',border:'8px solid #8b4513',boxShadow:'0 8px 24px rgba(0,0,0,0.6), inset 0 0 20px rgba(0,0,0,0.3)',marginBottom:'10px'}}>
                  <div style={{marginBottom:'10px'}}><BetBox betType="pass" label="PASS LINE" style={{height:'70px',fontSize:'28px',background:'rgba(255,255,255,0.15)',fontWeight:'bold'}}/></div>
                  <div><BetBox betType="dontpass" label="DON'T PASS BAR üé≤üé≤" style={{height:'60px',fontSize:'18px',background:'rgba(255,255,255,0.1)'}}/></div>
                </div>

                <div style={{background:'linear-gradient(135deg, #000 0%, #1a1a1a 100%)',color:'#fff',padding:'15px',borderRadius:'10px',boxShadow:'0 4px 12px rgba(0,0,0,0.5)',border:'2px solid #ffd700'}}>
                  <div style={{display:'flex',justifyContent:'space-between',alignItems:'center',marginBottom:'15px'}}>
                    <h3 style={{fontWeight:'bold',fontSize:'18px',color:'#ffd700'}}>Players ({gameState.players.length}/6)</h3>
                    <button onClick={async()=>{if(window.confirm('Reset table? All players and bets will be cleared.')){const ng=initializeGame();await saveToServer(ng);sessionStorage.removeItem('craps-player-id');setPlayerId(null);playerIdRef.current=null;setShowJoinModal(true);}}}
                      style={{background:'#666',color:'#fff',padding:'8px 15px',borderRadius:'5px',border:'none',fontSize:'12px',cursor:'pointer'}}>Reset</button>
                  </div>
                  <div style={{display:'flex',flexDirection:'column',gap:'8px'}}>
                    {gameState.playerOrder?.map((pid,idx)=>{
                      const player=gameState.players.find(p=>p.id===pid); if(!player)return null;
                      return(
                        <div key={player.id} style={{display:'flex',justifyContent:'space-between',alignItems:'center',padding:'12px',borderRadius:'8px',
                          background:player.id===playerId?'linear-gradient(135deg, #ffd700 0%, #ffed4e 100%)':'#333',
                          color:player.id===playerId?'#000':'#fff',fontWeight:'bold',
                          border:idx===gameState.currentShooter?'3px solid #ff0000':'none'}}>
                          <span>{idx===gameState.currentShooter&&'üé≤ '}{player.name}{player.id===playerId&&' (YOU)'}</span>
                          <span style={{fontSize:'18px',color:player.id===playerId?(player.chips>=STARTING_CHIPS?'#00aa00':'#ff0000'):(player.chips>=STARTING_CHIPS?'#00ff00':'#ff6666')}}>${player.chips}</span>
                        </div>
                      );
                    })}
                  </div>
                </div>
              </div>
            </div>
          );
        };
        ReactDOM.render(<CrapsGame/>,document.getElementById('root'));
    </script>
</body>
</html>
